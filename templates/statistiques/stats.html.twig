{% extends 'base.html.twig' %}

{% block titrePage %}{{ titre }}{% endblock %}

{% block statistiques %}active{% endblock %}

{% block stylesheets %}
  <style>
    .card:hover{
      -webkit-box-shadow: -1px 9px 40px -12px rgba(0,0,0,0.75);
      -moz-box-shadow: -1px 9px 40px -12px rgba(0,0,0,0.75);
      box-shadow: -1px 9px 40px -12px rgba(0, 0, 0, 0.75);
    }
  </style>
{% endblock %}

{% block contenu %}
<div class="table-responsive">
<table align="center" class="table">
  <tbody>
    {% if plusieursEvals %}
      <tr>
        <th>Évaluations sélectionnées</th>
        <td>
          <ul>
            {% for evaluation in evaluations %}
              <li>{{ evaluation.nom }} ({{ evaluation.date|date("d/m/Y") }})</li>
            {% endfor %}
          </ul>
        </td>
      </tr>
      <tr>
        <th>Groupes sélectionnés</th>
        <td>
          <ul>
            {% for groupe in parties[0].stats %}
              <li>{{ groupe.nom }} ({{ groupe.listeNotes|length }} notes étudiées)</li>
            {% endfor %}
          </ul>
        </td>
      </tr>
    {% else %}
      <tr>
        <th class="intitule"><label for="evaluation_groupe" >Groupe évalué</label></th>
        <td >{{evaluation.groupe.nom}}</td>
      </tr>
      <tr>
        <th class="intitule"><label for="evaluation_date" >Date de l'évaluation</label></th>
        <td >{{evaluation.date | date("d/m/Y")}}</td>
      </tr>
    {% endif %}
    <tr>
      <th class="intitule"><label >Actions</label></th>
      <td>
      <a href="#"><i style="font-size: 25px;" data-toggle='tooltip' title="Exporter les statistiques au format PDF (Portrait)" class="icon-file-pdf" onclick="genPDF(onChartReady, true)"></i></a>
      <a href="#"><i style="font-size: 25px;" data-toggle='tooltip' title="Exporter les statistiques au format PDF (Paysage)" class="fas icon-file-pdf fa-rotate-270" onclick="genPDF(onChartReady, false)"></i></a>
      {% if not plusieursEvals %}
          {% if (evaluation.enseignant.id == app.user.id or is_granted('ROLE_ADMIN')) %}
            <a href="{{path("previsualisation_mail", {slug:evaluation.slug})}}"><i style="font-size: 25px;"  data-toggle='tooltip' title="Envoyer les statistiques aux étudiants"  class="icon-mail"></i></a>
          {% endif %}
        {% endif %}
      </td>
    </tr>
  </tbody>
</table>
</div>
{% for message in app.flashes('info') %}
<div class="alert alert-success" role="alert">
  {{ message }}
</div>
{% endfor %}
<div class='bouton' align=center>
  <span style="font-size:15px" class="badge badge-pill badge-primary"><i class="icon-attention-circled"></i> Les statistiques ne prennent pas en compte les étudiants démissionaires ou absents</span>
</div>
{# récupération du type de graphique récupéré à la première étape #}
{% set tabActive = app.session.get('typeGraphique') %}
{% if parties is not empty %}
  {% for partie in parties %}
    <div class="card">
      <ul class="list-group list-group-flush">
        <li class="list-group-item text-white" style="background-color:#bdc3c7;">
          {{ partie.nom }} (/{{ partie.bareme }})
        </li>
        <li class="list-group-item">
          <ul class="nav nav-tabs">
            <li class="nav-item"><a class="nav-link {% if tabActive =="histogramme" %}active{% endif %}" data-toggle="tab" href="#Repartition_Histogramme_{{ partie.nom | replace({' ': '_'}) }}">Répartition (Histogramme)</a></li>
            <li class="nav-item"><a class="nav-link {% if tabActive =="boite-moustache" %}active{% endif %}" data-toggle="tab" href="#Repartition_Boites_{{ partie.nom | replace({' ': '_'}) }}">Répartition (Boîte à moustaches)</a></li>
            <li class="nav-item"><a class="nav-link {% if tabActive =="moyenne" %}active{% endif %}" data-toggle="tab" href="#Moyenne_ecart_{{ partie.nom | replace({' ': '_'}) }}">Moyenne & Écart-type</a></li>
          </ul>
          <div class="tab-content">
            <!-- Répartition (Histogramme) -->
            <div id="Repartition_Histogramme_{{ partie.nom | replace({' ': '_'}) }}" class="tab-pane {% if tabActive =="histogramme" %}active{% else %}fade{% endif %}">
              <div class="container-fluid">
                <br>
                <div class="card-md-auto">
                  <div class="card-header" style="background-color: transparent">
                    Groupes
                  </div>
                  <div class="card-body">
                    {% set tabCounter = 0 %}
                    {% for groupe in parties[0].stats %}
                      <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="{{groupe.nom}}" checked onChange="changement(this.id, this.checked, '{{ loop.parent.loop.index -1 }}', 'histo')">
                        <label class="form-check-label" for="inlineCheckbox1" name="label_{{groupe.nom}}_histo">{{groupe.nom}}</label>
                      </div>
                      {% set tabCounter = tabCounter + 1 %}
                    {% endfor %}
                  </div>
                </div>
              </div>
              <br>
              <div class="container-fluid">
                <span style="font-size:15px"><i class="icon-attention-circled"></i>Survolez le graphique pour plus d'informations</span>
                <canvas align=center id="graphHisto_{{ loop.index -1 }}"></canvas>
              </div>
            </div>
            <!-- fin Répartition (Histogramme) -->
            <!-- Répartition (Boîte à moustache) -->
            <div id="Repartition_Boites_{{ partie.nom | replace({' ': '_'}) }}" class="tab-pane {% if tabActive =="boite-moustache" %}active{% else %}fade{% endif %}">
              <div class="container-fluid">
                <br>
                <div class="card-md-auto">
                  <div class="card-header" style="background-color: transparent">
                    Groupes
                  </div>
                  <div class="card-body">
                    {% set tabCounter = 0 %}
                    {% for groupe in parties[0].stats %}
                      <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="{{groupe.nom}}" checked onChange="changement(this.id, this.checked, '{{ loop.parent.loop.index -1 }}', 'bam')">
                        <label class="form-check-label" for="inlineCheckbox1" name="label_{{groupe.nom}}_bam">{{groupe.nom}}</label>
                      </div>
                      {% set tabCounter = tabCounter + 1 %}
                    {% endfor %}
                  </div>
                </div>
              </div>
              <br>
              <div class="container-fluid">
                <span style="font-size:15px"><i class="icon-attention-circled"></i>Survolez le graphique pour plus d'informations</span>
                <canvas align=center id="graphBoites_{{ loop.index -1 }}"></canvas>
              </div>
            </div>
            <!-- fin Répartition (Boîtes à moustache) -->
            <!-- Moyenne & Ecart-type -->
            <div id="Moyenne_ecart_{{ partie.nom | replace({' ': '_'}) }}" class="tab-pane {% if tabActive =="moyenne" %}active{% else %}fade{% endif %}">
              <div class="container-fluid">
                <br>
                <div class="card-md-auto">
                  <div class="card-header" style="background-color: transparent">
                    Groupes
                  </div>
                  <div class="card-body">
                    {% set tabCounter = 0 %}
                    {% for groupe in parties[0].stats %}
                      <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="{{groupe.nom}}" checked onChange="changement(this.id, this.checked, '{{ loop.parent.loop.index -1 }}', 'moy')">
                        <label class="form-check-label" for="inlineCheckbox1" name="label_{{groupe.nom}}_moy">{{groupe.nom}}</label>
                      </div>
                      {% set tabCounter = tabCounter + 1 %}
                    {% endfor %}
                  </div>
                </div>
              </div>
              <br>
              <div class="container-fluid">
                <span style="font-size:15px"><i class="icon-attention-circled"></i>Survolez le graphique pour plus d'informations</span>
                <canvas align=center id="grapheMoyenne_{{ loop.index -1 }}"></canvas>
              </div>
            </div>
            <!-- fin Moyenne & Ecart-type -->
          </div>
        </li>
      </ul>
    </div>
    <br>
  {% endfor %}
{% else %}
<div class="info">
  <h2 class="h4 mb-0 text-gray-800">Veuillez sélectionner des parties de l'évaluations sur lesquelles voir des statistiques </h2>
</div>
{% endif %}
{% endblock %}

{% block javascripts %}

<!-- Import de pdfmake -->
<script type="text/javascript" src="{{asset("js/pdfmake.min.js")}}"></script>
<script type="text/javascript" src="{{asset("js/vfs_fonts.js")}}"></script>
<!-- Script pour les graphiques de type 'Boîte à moustache' -->
<script type="text/javascript" src="{{asset("js/boxplot.js")}}"></script>

<!-- Script pour la génération des graphiques -->
<script type="text/javascript">

  // ----- VARIABLES GLOBALES ---------
  {% if plusieursEvals %}
    var nomEvaluation = "Synthèse des {{evaluations.count}} evaluation(s)"
  {% else %}
    var nomEvaluation = "{{evaluation.nom}}";
  {% endif %}

  // Taille de la police du graphique affiché
  var fontSize = 16;

  var wait_for_chart_ready = false; // Faux, si le graphique est en cours de création -> Vrai une fois que le graphique est prêt à être exporté en Image pour le pdf

  // Liste de couleurs communes
  var noir = "#000000", jaune = "#FFFF00", bleu = "#0000FF", rouge = "#FF0000", vert = "#00FF00", violet = "#EE82EE", blanc = "#FFFFFF", gris = "#808080";

  // Pallette de couleurs (valeurs rgb)
  // Pallette de couleurs (valeurs rgb)
  var couleurs = [
    [192, 57, 43], [155, 89, 182], [41, 128, 185], [22, 160, 133], [46, 204, 113], [243, 156, 18], [211, 84, 0], [189, 195, 199], [127, 140, 141],
    [44, 62, 80], [231, 76, 60], [142, 68, 173], [26, 188, 156], [39, 174, 96], [241, 196, 15], [230, 126, 34], [236, 240, 241], [149, 165, 166],
    [52, 73, 94],
  ];

  // passage de la liste des parties de twig à js
  var parties = "{{parties|json_encode()}}";
  parties = parties.replace(/&quot;/g, "\""); // remplacement de toutes les itérations de ' &quot; ' par ' " '
  parties = JSON.parse(parties);

  // Récupération de la liste des groupes de twig à js (on récupère la liste des groupes de la premiere partie car ce sont tous les memes pour chacune)
  {% if parties is not empty %}
    var groupes = "{{parties[0].stats|json_encode()}}";
    groupes = groupes.replace(/&quot;/g, "\""); // remplacement de toutes les itérations de ' &quot; ' par ' " '
    groupes = JSON.parse(groupes);
  {% else %}
    var groupes = {};
  {% endif %}

  // Groupes sélectionés (avec les cases à cocher) par graphique
  var groupesChecked = [];
  {% for partie in parties %}
  groupesCheckedParPartie = [];
  groupesCheckedParPartie['histo']= [];
  groupesCheckedParPartie['bam'] = [];
  groupesCheckedParPartie['moy'] = [];
  groupesChecked.push(groupesCheckedParPartie);
  {% endfor %}

  // Objet données du graphique
  const chartDATA = {
    labels: [],
    datasets: undefined,
  };

  // Taille de police d'écriture pour les graphiques exportés dans le fichier PDF
  const pdfChartFontSize = 24;

  // Liste des images des graphiques pour le fichier PDF.
  var images = undefined;

  //Contiendra les variables des graphiques pour les mettre à jour
  var graphiques = [];

  // Objet options du graphique
  var options = {
    scales: {
      xAxes: [{
        gridLines: {
          display: false
        },
        ticks: {
          fontSize: fontSize,
        },
        maxBarThickness: 100,
        stacked: false,
      }],
      yAxes: [{
        labelString: 'Intervalle de note',
        ticks: {
          beginAtZero: true,
          max: 10,
          min: 0,
          fontSize: fontSize,
        },
        stacked: false,
      }],
    },
    legend: {
      position: 'top',
      labels: {
        fontSize: fontSize,
        },
	  },
    aspectRatio: 3,
    maintainAspectRatio: true,
    responsive: true,
    tooltips: {
      intersect: false,
      titleMarginBottom: 10,
      titleFontColor: '#6e707e',
      titleFontSize: fontSize,
      backgroundColor: blanc,
      bodyFontColor: "#858796",
      borderColor: '#dddfeb',
      borderWidth: 1,
      xPadding: 15,
      yPadding: 15,
      displayColors: true,
      caretPadding: 10
    },
    plugins : {
      labels: {
        render: 'value'
      }
    }
  }

 // --------- CODE ------------

  // Création des graphiques au chargement de la fenètre
  window.onload = function(){
    {% for partie in parties %}
        var graphiquesPartieCourante =  [];

        var chartBar = new Chart(document.getElementById("graphHisto_{{ loop.index -1 }}").getContext('2d'), {
          type: 'bar',
          data: chartDATA,
          options: options
        });
        graphiquesPartieCourante.push(chartBar);

        var chartBoite = new Chart(document.getElementById("graphBoites_{{ loop.index -1 }}").getContext('2d'), {
          type: 'boxplot',
          data: chartDATA,
          options: options,
        });
        graphiquesPartieCourante.push(chartBoite);

        var chartMoy = new Chart(document.getElementById("grapheMoyenne_{{ loop.index -1 }}").getContext('2d'), {
          type: 'bar',
          data: chartDATA,
          options: options,
        });
        graphiquesPartieCourante.push(chartMoy)
        graphiques.push(graphiquesPartieCourante)
    {% endfor %}

    {# Pour que toutes les cases soient cochées par défaut #}
    {% for partie in parties %}
      {% for groupe in partie.stats %}
        changement("{{ groupe.nom }}", true, {{ loop.parent.loop.index -1 }}, "histo" )
        changement("{{ groupe.nom }}", true, {{ loop.parent.loop.index -1 }}, "bam" )
        changement("{{ groupe.nom }}", true, {{ loop.parent.loop.index -1 }}, "moy" )
      {% endfor %}
    {% endfor %}
    // Mise en forme du texte des cases à cocher
    formatageCasesACocher();
  }

//------ FONCTIONS -----

// Coloration du texte des cases à cocher avec les bonnes couleurs + réajustement de la taille de la police
// Chaque label de case à cocher à comme id : label_nomGroupe_nomGraphe
function formatageCasesACocher(){
  // Création de couleurs si la liste couleurs n'as pas assez d'éléments
  if(groupes.length > couleurs.length){
    var gap = groupes.length - couleurs.length;
    for(var i = 0; i < gap; i++){
      var coul = couleurs[i];
      couleurs.push([(coul[0] + 60) % 255, (coul[1] - 60) % 255, coul[2]]);
    }
  }
  for(var i = 0; i < groupes.length; i++) {
    labelsHistogramme = document.getElementsByName("label_" + groupes[i].nom +"_histo");
    for(var j =0; j < labelsHistogramme.length ; j++ ) {
      var rgb = "rgb("+couleurs[i][0]+","+couleurs[i][1]+","+couleurs[i][2]+")";
      labelsHistogramme[j].style.color = rgb;
      labelsHistogramme[j].style.fontSize = (fontSize+"px");
    }

    labelsBAM = document.getElementsByName("label_" + groupes[i].nom +"_bam");
    for(var j =0; j < labelsBAM.length ; j++ ) {
      var rgb = "rgb("+couleurs[i][0]+","+couleurs[i][1]+","+couleurs[i][2]+")";
      labelsBAM[j].style.color = rgb;
      labelsBAM[j].style.fontSize = (fontSize+"px");
    }
  }
}

// Met à jour le graphique en fonction des cases qui sont cochées
function changement(nom, value, partieConcernee, typeStat){
  // Gère l'addition et la suppression des groupes à afficher dans le graphe
  if(value){ // la case à été cochée
    groupesChecked[partieConcernee][typeStat].push(nom); // Ajout dans la liste cochée
  } else { // la case à été décochée
      var index = contains(groupesChecked[partieConcernee][typeStat], nom); // index au quel se trouve le groupe dans le tableau groupes s'il existe
      if(index != -1){
        groupesChecked[partieConcernee][typeStat].splice(index, 1); // Suppression de la liste cochée
      }
  }

  var chartOptions = options; // Récupération de la template des options
  var chartDonnees = {};
  // Récupération de la template des données du graphique
  // Génération des labels & cacul du max
  switch (typeStat) {
    case 'histo':
      // Changement des labels + de l'échelle de l'axe Y
      chartDonnees.labels = ['[0;4[', '[4;8[', '[8;12[', '[12;16[', '[16;20]'];
      chartOptions.scales.yAxes[0].ticks.min = 0;
      chartOptions.scales.yAxes[0].ticks.max = undefined;
      break;
    case 'bam': // Boîte à moustache
      // Changement des labels + de l'échelle de l'axe Y
      chartDonnees.labels = [nomEvaluation];
      chartOptions.scales.yAxes[0].ticks.min = 0;
      chartOptions.scales.yAxes[0].ticks.max = undefined;
      break;
    case 'moy':
      chartDonnees.labels = groupesChecked[partieConcernee][typeStat];
      chartOptions.scales.yAxes[0].ticks.min = undefined;
      chartOptions.scales.yAxes[0].ticks.max = undefined;
      break;
    default:
      break;
  }

  // Génération des datasets des groupes sélectionés pour chartJS en fonction du graphique sélectioné
  // Remplacement des données du graphe par les nouvelles données générées
  switch(typeStat){
    case 'histo':
    case 'bam':
      chartDonnees.datasets = genDataRepartition(typeStat, partieConcernee);
      break;
    case 'moy':
      chartDonnees.datasets = genDataMoyenneEcart(partieConcernee);
      break;
  }

  //  MaJ du graphique + MaJ des options
  switch (typeStat) {
    case 'histo':
      graphiques[partieConcernee][0].options = chartOptions;
      graphiques[partieConcernee][0].data = chartDonnees;
      graphiques[partieConcernee][0].update();
      break;
    case 'bam': // Boîte à moustaches
      graphiques[partieConcernee][1].options = chartOptions;
      graphiques[partieConcernee][1].data = chartDonnees;
      graphiques[partieConcernee][1].update();
      break;
    case 'moy' : // Moyenne & écart-type
      graphiques[partieConcernee][2].options = chartOptions;
      graphiques[partieConcernee][2].data = chartDonnees;
      graphiques[partieConcernee][2].update();
      break;
    default:
      break;
  }
}

function genDataRepartition(type, partieConcernee){
  var data = [];
  for(var j = 0; j < groupesChecked[partieConcernee][type].length; j++){
    var set = {};
    var indexGroupe = -1;
    for(var l = 0; l < parties[partieConcernee].stats.length; l++) {
      if(groupes[l].nom == groupesChecked[partieConcernee][type][j]) {
        indexGroupe = l;
      }
    }
    if(indexGroupe != -1){
      set.label = groupes[indexGroupe].nom;
      switch (type) {
        case 'histo': // Histogramme
          set.data = parties[partieConcernee].stats[indexGroupe].repartition;
          set.borderColor = gris;
          break;
        case 'bam': // Boîte à moustaches
          set.data = [parties[partieConcernee].stats[indexGroupe].listeNotes];
          set.borderColor = noir;
          break;
        default:
          break;
      }
      var rgb = "rgb("+couleurs[indexGroupe][0]+","+couleurs[indexGroupe][1]+","+couleurs[indexGroupe][2]+")";
      set.backgroundColor = rgb;
      set.hoverBackgroundColor = rgb;
      data.push(set);
    }
  }
  return data;
}

// Génère les données requises par Chart.js pour le graphique 'Moyenne & écart-type'
function genDataMoyenneEcart(partieConcernee){
  var liste = getGroupesData(groupesChecked[partieConcernee]['moy'], partieConcernee); // Récupération des données
  var moyenne = [];
  var ecartType = [];
  for(var i = 0; i < liste.length; i++){ // Choix des informations requises
    moyenne.push(liste[i].moyenne);
    ecartType.push(liste[i].ecartType);
  }
  var couleurMoyenne = couleurs[0];
  var couleurEcartType = couleurs[1];
  data = [ // Création des objets datasets de Chart.js avec nos données
    {
      label: 'Moyenne',
      backgroundColor: "rgb("+couleurMoyenne[0]+","+couleurMoyenne[1]+","+couleurMoyenne[2]+")",
      hoverBackgroundColor: "rgb("+couleurMoyenne[0]+","+couleurMoyenne[1]+","+couleurMoyenne[2]+")",
      borderColor: gris,
      data: moyenne
    },
    {
      label: 'Écart-type',
      backgroundColor: "rgb("+couleurEcartType[0]+","+couleurEcartType[1]+","+couleurEcartType[2]+")",
      hoverBackgroundColor: "rgb("+couleurEcartType[0]+","+couleurEcartType[1]+","+couleurEcartType[2]+")",
      borderColor: gris,
      data: ecartType
    }
  ];
  return data;
}

// Retourne un tableau d'objets groupe avec leurs données en fonction d'une liste de noms de groupes
function getGroupesData(listeGroupes, partieConcernee){
  groupesAvecDonnees = [];
  for(var i = 0; i < listeGroupes.length; i++){
    for (var j = 0; j < parties[partieConcernee].stats.length ; j++) {
      if(parties[partieConcernee].stats[j].nom == listeGroupes[i]) {
        groupesAvecDonnees.push(parties[partieConcernee].stats[j]);
      }
    }
  }
  return groupesAvecDonnees;
}

// génère des codes couleurs rgb aléatoires
function genRandomColor(){
  return "rgb(" + Math.floor(Math.random() * Math.floor(255)) + ","
                + Math.floor(Math.random() * Math.floor(255)) + ","
                + Math.floor(Math.random() * Math.floor(255)) + ")";
}

// retourne l'index au quel se trouve l'élément dans array, s'il n'y est pas renvoie -1
function contains(array, element){
  for(var i = 0; i < array.length; i++){
    if(array[i] == element){
      return i;
    }
  }
  return -1;
}

//----------------- PARTIE GENERATION DE PDF -------------

function getImages(largeur, longueur, callback){

  // options du graphique pour la génération de graphiques pour le pdf.
  const pdfChartOptions = {animation:{
    onComplete: callback,
    duration: false, },scales:{xAxes:[{gridLines:{display:!1},ticks:{fontSize:pdfChartFontSize,},maxBarThickness:100,stacked:!1,}],yAxes:[{ticks:{beginAtZero:!0,max:undefined,min:0,fontSize:pdfChartFontSize},stacked:!1,}],},legend:{position:'top',labels:{fontSize:pdfChartFontSize,},},aspectRatio:3,maintainAspectRatio:!0,responsive:!1,tooltips:{intersect:!1,titleMarginBottom:10,titleFontColor:'#6e707e',titleFontSize:fontSize,backgroundColor:"#FFFFFF",bodyFontColor:"#858796",borderColor:'#dddfeb',borderWidth:1,xPadding:15,yPadding:15,displayColors:!0,caretPadding:10,},plugins:{labels:{render:'value'}}};

  images = [];

  for(var indexPartie = 0; indexPartie < groupesChecked.length; indexPartie++){
    for(var clef in groupesChecked[indexPartie]){
      // Création du canvas caché
      var canvas = document.createElement("canvas");
      canvas.setAttribute('id', 'hiddenGraph');
      canvas.style.display = 'none'; // N'affiche pas l'élément
      canvas.style.width = largeur+'px';
      canvas.style.height = longueur+'px';
      document.body.appendChild(canvas);

      var chartDonnees = {};
      var options = pdfChartOptions;
      switch (clef) {
        case 'histo':
          chartDonnees.labels = ['[0;4[', '[4;8[', '[8;12[', '[12;16[', '[16;20]'];
          options.scales.yAxes[0].ticks.min = 0;
          options.scales.yAxes[0].ticks.max = undefined;
          break;
        case 'bam': // Boîte à moustache
          chartDonnees.labels = [nomEvaluation];
          options.scales.yAxes[0].ticks.min = 0;
          options.scales.yAxes[0].ticks.max = undefined;
          break;
        case 'moy':
          chartDonnees.labels = groupesChecked[indexPartie][clef];
          options.scales.yAxes[0].ticks.min = 0;
          options.scales.yAxes[0].ticks.max = undefined;
          break;
        default:
          break;
      }

      // Génération des données nécessaires à la bonne creation du graphique
      chartDonnees.datasets = (clef == 'moy' ? genDataMoyenneEcart(indexPartie) : genDataRepartition(clef, indexPartie));

      // Création du chart dans le canvas caché
      window.hiddenGraph = new Chart(document.getElementById("hiddenGraph").getContext('2d'), {
        type: (clef == 'bam' ? 'boxplot' : 'bar'),
        data: chartDonnees,
        options: options,
      });

      // Attente de la génération du graphique, le booléen change d'état dans la fonction callback
      while(!wait_for_chart_ready){};
      wait_for_chart_ready = !wait_for_chart_ready;

      // Ajout de l'image à l'array
      images.push(window.hiddenGraph.toBase64Image());

      // Supression de l'instance du graphique
      window.hiddenGraph.destroy();

      // Suppression du canvas caché de l'arborescence de la page
      document.body.removeChild(canvas);
    }
  }
}

// Fonction appelée par une fois le graphique généré, permet au programme de savoir quand demander la valeur PNG du graphique
function onChartReady(){
  wait_for_chart_ready = true;
}

function genPDF(callback, portrait){

  // CONSTANTES
  const imageWidthPortrait = 500
  const imageWidthPaysage = 780;
  const largeurCanvas = 1500;
  const longueurCanvas = 650;

  // Génération des images des graphiques pour le pdf
  getImages(largeurCanvas, longueurCanvas, callback);

  // Contenu du pdf à générer
  var docDefinition = {
    compress: false,
    footer: function(currentPage, pageCount) { return {
        columns: [
          { text: 'Document généré par l\'application Noteo', alignment: 'center', italics: true},
          { text: (currentPage.toString() + " "), alignment: 'right', margin: [0,0,35,25]},
        ]
      };
    },
    pageOrientation: (portrait ? 'portrait' : 'landscape'),
    info: {
      title: '{{evaluation.nom}}',
      author: 'Noteo',
    },
    content: [
      { // PAGE DE GARDE
  			text: '{{evaluation.nom}}\n({{evaluation.date|date("d/m/Y")}})\n',
  			style: 'header',
  		},
      { // TABLES DES MATIERES
        toc: {
          id: 'tabMatieres',
          title: {
            text: 'Table des matières',
            style: 'header',
          },
        },
        pageBreak: 'after',
    },
    ],
    // images : {
    //   histo : images[0],
    //   bam : images[1],
    //   moy : images[2],
    // },
    styles: {
  		header: {
  			fontSize: 18,
  			bold: true,
        alignment: 'center',
        margin: [5, 30],
  		},
  		subheader: {
  			fontSize: 18,
        margin: 15,
  		},
      subheader_paysage: {
  			fontSize: 22,
        margin: 25,
  		},
      titre: {
        fontSize: 18,
        margin: 15,
      },
      un_peu_plus_grand: {
        fontSize: 14,
        margin: 15,
      },
      tableau: {
			   margin: 15,
         alignment: 'center',
		  },
      texte_header_tableau_portrait: {
        margin: 5,
      },
      texte_header_tableau_paysage: {
        margin: 10,
      },
	   }
  };

  // Génération des pages
  for(var indexPartie = 0; indexPartie < groupesChecked.length; indexPartie++){
    var nomPartie = parties[indexPartie].nom + " (/" + parties[indexPartie].bareme+")";
    var compteurTypeGraph = 0;
    var fin_compteur = Object.keys(groupesChecked[indexPartie]).length;
    for(clef in groupesChecked[indexPartie]){
      compteurTypeGraph++;
      var contenu = [
        {
          text: (clef == 'moy' ? 'Moyenne et écart-type' : (clef == 'bam' ? 'Répartition des notes (Boîte à moustaches)' : 'Répartition des notes (Histogramme)')) + (groupesChecked.length > 1 ? " - Partie : " + nomPartie : ''),
          style: (portrait ? 'subheader' : 'subheader_paysage'),
          tocItem: 'tabMatieres',
        },
        {
          image: images[indexPartie*3+compteurTypeGraph-1],
          width: (portrait ? imageWidthPortrait : imageWidthPaysage),
          pageBreak: (portrait ? '' : 'after'),
        },
        {
          text: (clef == 'moy' ? 'Moyenne et écart-type' : 'Répartition des notes') + " (Données chiffrées)",
          style: 'subheader',
        },
  		  {
    			style: 'tableau',
    			table: {
            headerRows: 1,
    				body: getDataForPdfTable(clef, indexPartie, portrait),
    			},
    			layout: { // Colore une ligne sur 2 (pour l'effet zèbré sur le tableau)
    				fillColor: function (rowIndex, node, columnIndex) {
    					return (rowIndex % 2 === 0) ? '#CCCCCC' : null;
    				}
    			},
          // Saut de page s'il reste encore des graphiques à ajouter au pdf
          pageBreak: (compteurTypeGraph == fin_compteur && indexPartie == groupesChecked.length-1 ? '' : 'after'),
  		  },
      ];
      docDefinition.content.push(contenu);
    }
  }

  // Génération du pdf en fonction de docDefinition et téléchargement de ce dernier
  pdfMake.createPdf(docDefinition).download(nomEvaluation);
}

// Génère les tableaux de données déstinés au fichier pdf
function getDataForPdfTable(clef, partieConcernee, portrait){
  var donnees = []; // Donées du tableau
  var groupesData = getGroupesData(groupesChecked[partieConcernee][clef], partieConcernee);
  switch(clef){
    case 'histo':
      var header = [];
      header.push({text: 'Groupe', style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}); // Case vide en haut à gauche
      // Création du header du tableau en fonction des labels du graphique
      // graphiques[partieConcernee][0] est le graphique de Répartion (Histogramme) de la partie partieConcernée
      for(var i = 0; i < graphiques[partieConcernee][0].data.labels.length; i++){
        header.push({text: graphiques[partieConcernee][0].data.labels[i], style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')});
      }
      donnees.push(header);
      for(var i = 0; i < groupesChecked[partieConcernee][clef].length; i++){
          var temp_row = [];
          temp_row.push(groupesChecked[partieConcernee][clef][i]);
          for(var j = 0; j < 5; j++){
            temp_row.push(groupesData[i].repartition[j]);
          }
          donnees.push(temp_row);
      }
      break;
    case 'moy':
      donnees.push([{text: "Groupe", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Moyenne", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Ecart-type", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Effectif", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}]); // header du tableau
      for(var i = 0; i < groupesChecked[partieConcernee][clef].length; i++){
          var temp_row = [];
          temp_row.push(groupesChecked[partieConcernee][clef][i]);
          temp_row.push(groupesData[i].moyenne);
          temp_row.push(groupesData[i].ecartType);
          temp_row.push(groupesData[i].listeNotes.length);
          donnees.push(temp_row);
      }
      break;
    case 'bam':
    donnees.push([{text: "Groupe", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Moyenne", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Ecart-type", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Minimum", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Médiane", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Maximum", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}, {text: "Effectif", style: (portrait ? 'texte_header_tableau_portrait' : 'texte_header_tableau_paysage')}]); // header du tableau
    // Création des lignes du tableau (1 ligne par groupe)
    for(var i = 0; i < groupesChecked[partieConcernee][clef].length; i++){
        var temp_row = [];
        temp_row.push(groupesChecked[partieConcernee][clef][i]);
        temp_row.push(groupesData[i].moyenne);
        temp_row.push(groupesData[i].ecartType);
        temp_row.push(groupesData[i].minimum);
        temp_row.push(groupesData[i].mediane);
        temp_row.push(groupesData[i].maximum);
        temp_row.push(groupesData[i].listeNotes.length);
        donnees.push(temp_row);
    }
      break;
  }
  return donnees;
}
</script>

{% endblock %}
